<?php
/*
 * 命名空间 - 名称解析规则
 */

# Example 1 名称解析示例
namespace A;
use B\D, C\E as F;

// 函数调用

foo(); // 首先尝试调用定义在命名空间 "A" 中的函数 foo()
       // 再尝试调用全局函数 "foo"

\foo(); // 调用全局空间函数 "foo"


my\foo(); // 调用定义在命名空间 "A\my" 中函数 "foo"

F(); // 首先尝试调用定义在命名空间 "A" 中的函数 "F"
     // 再尝试调用全局函数 "F"

// 类引用

new B(); // 创建命名空间 "A" 中定义的类 "B" 的一个对象
         // 如果未找到，则尝试自动装载类 "A\B"


new D(); // 使用导入规则，创建命名空间 "B" 中定义的类 "D" 的一个对象
         // 如果未找到，则尝试自动装载类 "B\D"

new F(); // 使用导入规则，创建命名空间 "C" 中定义的类 "E" 的一个对象
         // 如果未找到，则尝试自动装载类 "C\E"

new \B(); // 创建定义在全局空间中的类 "B" 的一个对象
          // 如果未发现，则尝试自动装载类 "B"

new \D(); // 创建定义在全局空间中的类 "D" 的一个对象
          // 如果未发现，则尝试自动装载类 "D"

new \F(); // 创建定义在全局空间中的类 "F" 的一个对象
          // 如果未发现，则尝试自动装载类 "F"

// 调用另一个命名空间中的静态方法或命名空间函数

B\foo(); // 调用命名空间 "A\B" 中函数 "foo"

B::foo(); // 调用命名空间 "A" 中定义的类 "B" 的 "foo" 方法
          // 如果未找到类 "A\B"，则尝试自动装载类 "A\B"

D::foo(); // 使用导入规则，调用命名空间 "B" 中定义的类 "D" 的 "foo" 方法
          // 如果类 "B\D" 未找到，则尝试自动装载类 "B\D"

\B\foo(); // 调用命名空间 "B" 中的函数 "foo"

\B::foo(); // 调用全局空间中的类 "B" 的 "foo" 方法
           // 如果类 "B" 未找到，则尝试自动装载类 "B"

// 当前命名空间中的静态方法或函数

A\B::foo(); // 调用命名空间 "A\A" 中定义的类 "B" 的 "foo" 方法
            // 如果类 "A\A\B" 未找到，则尝试自动装载类 "A\A\B"

\A\B::foo(); // 调用命名空间 "A\B" 中定义的类 "B" 的 "foo" 方法
             // 如果类 "A\B" 未找到，则尝试自动装载类 "A\B"

