<?php
/*
 * 类与对象 - 对象序列化
 */

/* 序列化对象 -  在会话中存放对象 */

/**
 * 所有 php 里面的值都可以使用函数 serialize() 来返回一个包含字节流的字符串来表示。unserialize() 函数能够重新把字符串变回 php 原来的值。序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。
 *
 * 为了能够 unserialize() 一个对象，这个对象的类必须已经定义过。如果序列化类 A 的一个对象，将会返回一个跟类 A 相关，而且包含了对象所有变量值的字符串。如果要想在另外一个文件中解序列化一个对象，这个对象的类必须在解序列化之前定义，可以通过包含一个定义该类的文件或使用函数 spl_autoload_register() 来实现。
 */

# Example 1
// 见 classa.inc、page1.php、page2.php

// 当一个应用程序使用函数 session_register() 来保存对象到会话中时，在每个页面结束的时候这些对象都会自动序列化，而在每个页面开始的时候又自动解序列化。所以一旦对象被保存在会话中，整个应用程序的页面都能使用这些对象。但是，session_register() 在 PHP5.4.0 之后被移除了。

// 在应用程序中序列化对象以便在之后使用，强烈推荐在整个应用程序都包含对象的类的定义。不然有可能出现在解序列化对象的时候，没有找到该对象的类的定义，从而把没有方法的类 __PHP_incomplete_Class_Name 作为该对象的类，导致返回一个没有用的对象。

// 所以在上面的例子中，当运行 session_register('a'); ，把变量 $a 放在会话里之后，需要在每个页面都包含文件 classa.inc，而不是只有文件 page1.php 和 page2.php。

// 除了以上建议，可以在对象上使用 __sleep() 和 __wakeup() 方法对序列化/反序列化事件挂载钩子。使用 __sleep() 也能够让仅仅序列化对象的某些属性。

?>